# 要件定義書 - ブロックチェーンRAID5

## 1. はじめに

### 1.1. 背景・目的

#### 1.1.1. 目的
本システムの目的は、テキストやバイナリといったWEBリソースをブロックチェーン上に永続的に保存する「オンチェーンWEB」のPoCを行うことにある。  
その際、リソースを断片化し、複数のブロックチェーンに分散して保存する仕組みを構築する。

#### 1.1.2. 背景
一般的なブロックチェーンには、ネットワーク帯域や同期速度の観点からブロックごとにサイズ上限が設けられている。例えば、イーサリアムのブロックサイズ上限は約22KBと非常に小さく、10MBのファイルを保存しようとすると466個のブロック生成が必要となり、その間ネットワークを占有してしまう。この問題を解決し、大容量のデータをオンチェーンに保存可能とする新たな仕組みが必要である。  
先行事例としては「Internet Computer」が存在するが、こちらはいささか大規模すぎることと、独自のブロックチェーンエコシステムを採用しており、移植性・発展性に欠けること、そして、このエコシステムに参加するためには審査と高いハードウェア要件が存在し、現実的にはパブリックブロックチェーンと言えるものではないため、これらの諸問題を解決するよりミニマムで汎用性の高いシステムを提案する。

### 1.2. システム概要
本システムは、複数のブロックチェーン（データチェーン）を束ね、RAIDに類似した分散ストレージとして機能させる。

- WEBリソースを固定サイズの「データ断片」に分割する。
- 各断片を、それぞれ異なるデータチェーンに並列で保存する。
- どの断片がどのチェーンに保存されているかの所在情報（メタデータ）は、別途「メタデータチェーン」で一元管理する。
- クライアントからのリクエストを受け、データの断片化・分散保存・復元を行う「コントローラー」を中核コンポーネントとして配置する。

このアーキテクチャにより、単一チェーンのブロックサイズ上限に縛られることなく、実質的にスケーラブルなオンチェーンストレージを実現する。

### 1.3. 用語定義
- **現時点で定義されている内容**
    - **コントローラー:** WEBリソースを断片化してデータチェーンに保存したり、逆にデータチェーンから断片を取得して復元するコンポーネント。オフチェーンもしくは専用のチェーンの機能として配置される想定。
    - **メタデータチェーン (metachain):** どのデータ断片がどのデータチェーンにあるかというハッシュ情報（メタデータ）を記録・管理するブロックチェーン。
    - **データチェーン (datachain):** 断片化されたWEBリソースの実データを保存するためのブロックチェーン。複数台稼働させる。
    - **リレイヤー:** IBCプロトコルに基づき、各チェーン間の状態を同期させるために必要なコンポーネント。

- **追加・確認が必要な内容**
    - `IBC (Inter-Blockchain Communication)`
    - `Cosmos SDK`
    - `パリティ`
    - `DENOM`
    - `ニーモニック`
    - 上記を含む、プロジェクト内で利用される技術用語や概念の定義を網羅的にリスト化し、関係者間の認識を統一する必要がある。

## 2. 基本要件

### 2.1. 利害関係者（ステークホルダー）
- クライアント
    - システムを使う人の総称。このブロックチェーンストレージシステムにデータをアップロードする主体。これは実際のシステムではユーザーだし、システムに組み込む場合はシステムが主体となる。

- デプロイヤー
    - システムを開発、管理、運用する人や組織。現状は自分ひとり。

### 2.2. システムのスコープ
- **現時点で定義されている内容（やること）**
    - WEBリソース（ファイル）のアップロード機能。
        - URLに紐づけてまとまりを作る
    - URLを指定したWEBリソースのダウンロード機能。
        - WEBページとしての表示はブラウザが行う。

- **追加・確認が必要な内容（やらないこと）**
    - 一度アップロードしたファイルの更新・削除機能は提供するか？
        - ブロックチェーンの機能を活かして、物理削除はしない。論理削除で対応する。古いバージョンの閲覧も可能にする仕組みもほしいが、現状では対応しない。
    - ユーザー認証や、ファイルごとのアクセス制御は実装するか？
        - サーバーサイドでアプリを動かす仕組みの提供は難しいので、静的なサイトやクライアント側のみでの処理に限定する。サーバーサイドの仕組みはオフチェーンに実装することになるのがひとまず。
    - ファイルのアップロードやダウンロードに対する課金モデルは導入するか？
        - 現状、マネタイズの仕組みはPoCを複雑化しすぎるため考慮していない。ただし、BCの仕組みとしてどのタイミングでガス代がかかるのか、どの部分は安くor高くするべきなのかということは考える必要がある。

## 3. 機能要件

### 3.1. 機能一覧
- 必須の機能
    - データのアップロード
    - データのダウンロード
    - データの
- PoCの範囲では優先度の低い機能
    - アップロードされたファイルの一覧表示機能
    - ファイルの検索機能
    - ファイルの更新・削除機能
    - 古いバージョンの適用や閲覧

### 3.2. 業務フロー（ユースケース）

#### 3.2.1. アップロード処理

URLの重複を「コントローラーによる事前チェック」と「`metachain`による最終保証」のハイブリッド方式で防止するフローを定義します。

| ステップ | 担当 | アクション |
| :--- | :--- | :--- |
| **1. 指示** | **クライアント** | アップロードしたいWEBリソース（ディレクトリ）と公開したい**ルートURL**を**コントローラー**に渡す。 |
| **2. URL重複確認** | **コントローラー** → **Metachain** | **【事前チェック】** まず、指定されたルートURLが`Metachain`に既に存在しないか**クエリ**で問い合わせる。**存在した場合はエラーを返し、処理を中断する。** |
| **3. 分割** | **コントローラー** | 受け取ったリソース内の各ファイルを固定サイズの「データ断片」に分割し、任意で「パリティ断片」を生成する。 |
| **4. 分散保存** | **コントローラー** → **Datachain** | 各断片を、それぞれ別の**Datachain**に並列で送信し、保存先を示す`Index`を受け取る。 |
| **5. マニフェスト作成** | **コントローラー** | 全てのファイルの「相対パス」と、それに対応する「`Index`のリスト」をまとめた**マニフェスト（ファイル構成情報）を作成する。 |
| 6. マニフェスト登録 | コントローラー → Metachain | 作成したマニフェストをルートURLに紐付けて`Metachain`に登録するトランザクション**を送信する。<br>**【最終保証】** 万が一、重複したURLでトランザクションが送信された場合、`Metachain`自体のロジックがこれを拒否し、データの整合性を保証する。 |
| **7. 完了** | **コントローラー** → **クライアント** | `Metachain`への登録完了後、クライアントに完了通知を送る。 |


#### 3.2.2. ダウンロード処理
| ステップ | 担当 | アクション |
| :--- | :--- | :--- |
| **1. 要求** | **クライアント** | 閲覧したいURLを**コントローラー**に渡す。 |
| **2. 住所確認** | **コントローラー** → **Metachain** | **Metachain**にURLに対応するメタデータ（住所録）を問い合わせる。 |
| **3. 住所取得** | **Metachain** → **コントローラー** | **Metachain**は「断片データのありかリスト」をコントローラーに返却する。 |
| **4. データ収集** | **コントローラー** → **Datachain** | リストに基づき、各**Datachain**にデータ断片を並列で問い合わせる。 |
| **5. 結合・復元** | **コントローラー** | 全てのデータ断片を結合して元のファイルを復元する。（一部欠損時はパリティ断片で復元） |
| **6. 表示** | **コントローラー** → **クライアント** | 復元したファイルをクライアントに渡し、表示させる。 |

### 3.3. データ要件

#### `datachain`

  * **構造:** `index`と`data`フィールドで構成されたKey-Value型のデータ構造。
  * **概要:** 断片化されたWEBリソースデータを保存する。`index`は`<URLなどを元にしたハッシュ>-<連番>`のような形式にし、保存の順序を固定化する。

#### `metachain`

  * **方式:** **マニフェスト方式**を採用。
  * **構造:**
    ```json
    {
      "url": "string (Unique Key)",
      "manifest": {
        "[filePath: string]": "string[] (Index List)"
      }
    }
    ```
  * **概要:**
      * 特定のWEBサイトやリソース群を、一つのまとまりとして管理する。
      * **`url`**:
          * サイトのルートとなる一意なパス（例: `my-cool-site/`）。
          * この`url`が`metachain`内での**ユニークキー**となり、重複は許容されない。
      * **`manifest`**:
          * サイト内のファイル構成を定義するオブジェクト。
          * キー（`filePath`）には`/index.html`や`/css/style.css`といった**相対パス**が入る。
          * バリュー（`Index List`）には、各ファイルの実体を構成するデータ断片の`Index`（`datachain`上のアドレス）が配列として格納される。
      * この構造により、コントローラーはまず`url`を元にマニフェストを取得し、その後ブラウザから要求された相対パスに応じて必要なデータ断片を`datachain`から収集・復元することが可能になる。

### 3.4. 管理機能要件
- **定義が必要な内容**
    - 各チェーン（metachain, datachain）の死活監視やリソース（ディスク使用量、トランザクション詰まり等）を監視する機能。
    - 新しいデータチェーンをシステムに追加・削除する手順。
    - 不正なコンテンツのアップロードを検知・ブロックする機能。

### 3.5. 異常系（エラーハンドリング）要件
- **定義が必要な内容**
    - アップロード中に一部のデータチェーンが応答しない場合のリトライ処理、タイムアウト処理、エラー通知の仕様。
    - ダウンロード時にデータが欠損しており、パリティでも復元できない場合のクライアントへの応答仕様。
    - メタデータチェーンへの書き込みが失敗した場合のロールバック処理の仕様。
    - コントローラー自体がダウンした場合の縮退運転や復旧手順。

## 4. 非機能要件

### 4.1. 性能・拡張性
- **定義が必要な内容**
    - **応答時間:** 特定のファイルサイズ（例: 10MB, 100MB）におけるアップロード/ダウンロードの目標時間。
    - **スループット:** システム全体で1秒あたりに処理可能なリクエスト数の目標値。
    - **拡張性:** 将来的にデータチェーンを何台までスケールアウトさせることを想定しているか。

### 4.2. 可用性・信頼性
- **定義が必要な内容**
    - **稼働率:** システム全体の目標稼働率（例: 99.9%）。
    - **冗長性:** データチェーンが何台まで同時に停止しても、ファイルのダウンロード機能を維持できるか。
    - **目標復旧時間 (RTO):** 障害発生時に何時間（何分）以内にシステムを復旧させるか。
    - **目標復旧時点 (RPO):** 障害発生時にどの時点のデータまで復旧を保証するか。

### 4.3. セキュリティ
- **定義が必要な内容**
    - **認証・認可:** コントローラーを操作するための認証・認可方式（例: APIキー, OAuth2.0）。
    - **データ保護:** 保存するデータおよびクライアント-コントローラー間の通信経路の暗号化は必要か。
    - **鍵管理:** 各チェーンノードやリレイヤーが使用する秘密鍵をどのように安全に管理・運用するか。
    - **アクセス制御:** 特定のIPアドレスからのアクセス制限などは必要か。

### 4.4. 運用・保守性
- **現時点で定義されている内容**
    - `datachain`, `metachain`, `relayer` のDockerコンテナによる環境構築手順。
    - 各チェーンの起動時に、設定ファイル（`genesis.json`, `config.toml`, `app.toml`）を自動生成・構成する仕組み。
    - 冪等性（何度実行しても同じ状態になること）を考慮した初期化スクリプトの設計。

- **追加・確認が必要な内容**
    - **ログ設計:** 各コンポーネントが出力するログの内容、フォーマット、レベル（Info, Error 등）、およびログの収集・管理方法。
    - **監視設計:** 各コンポーネントの何を監視し（死活、CPU/メモリ使用率、ディスクI/O）、どのような閾値でアラートを通知するか。
    - **バックアップ・リストア:** 各チェーンの状態や設定ファイルのバックアップ手順と、障害発生時のリストア手順。

### 4.5. UI/UX要件
- **定義が必要な内容**
    - コントローラーが外部（クライアント）に提供するAPIのエンドポイント、HTTPメソッド、リクエスト/レスポンスのデータフォーマット仕様。
    - （もし必要であれば）システム管理者が利用する管理画面のワイヤーフレームや画面遷移図。

## 5. 制約条件

### 5.1. 技術的制約
- **ブロックチェーン基盤:** Cosmos SDKを利用して独自のチェーンを構築する。
- **チェーン間通信:** IBC (Inter-Blockchain Communication) プロトコルを利用する。→オフチェーンのコントローラーを使用した場合は用いない可能性。
- **実行環境:** 各コンポーネントはDockerコンテナとして構築し、Docker ComposeやKubernetes(k8s)によるオーケストレーションを想定する。
- **開発言語:** Go（`datachaind`コマンドの存在から推測）。
- **アーキテクチャ:** コントローラーはオフチェーンコンポーネントとして実装する。

### 5.2. プロジェクト制約
- **定義が必要な内容**
    - **予算:** 本プロジェクトに割り当てられた開発・運用予算。
    - **スケジュール:** リリース目標日、および主要な機能開発のマイルストーン。
    - **開発体制:** 開発チームの人数、役割分担（PM, エンジニア, etc.）。

## 6. その他

### 6.1. 移行要件
- **定義が必要な内容**
    - 既存のストレージシステムから本システムへデータを移行する必要があるか。ある場合、その手順と計画。

### 6.2. テスト計画
- **定義が必要な内容**
    - 単体テスト、結合テスト、性能テスト、セキュリティテストなど、各テストフェーズの方針と合格基準。

### 6.3. 納品物
- **定義が必要な内容**
    - プロジェクト完了時に納品する成果物の一覧。（例: 要件定義書、設計書、ソースコード一式、テスト報告書、運用マニュアル）